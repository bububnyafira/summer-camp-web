import * as React from 'react';
import { useDrop, useDrag } from 'react-dnd';
import clone from 'lodash/clone';
import toPath from 'lodash/toPath';

const ItemTypes = {
    COMPONENT: 'component',
    EDIT_FIELD: 'editField',
    FIELD: 'field',
    DYNAMIC_ZONE: 'dynamicZone',
    RELATION: 'relation',
    BLOCKS: 'blocks'
};

/**
 * Utility hook designed to implement keyboard accessibile drag and drop by
 * returning an onKeyDown handler to be passed to the drag icon button.
 *
 * @internal - You should use `useDragAndDrop` instead.
 */ const useKeyboardDragAndDrop = (active, index, { onCancel, onDropItem, onGrabItem, onMoveItem })=>{
    const [isSelected, setIsSelected] = React.useState(false);
    const handleMove = (movement)=>{
        if (!isSelected) {
            return;
        }
        if (typeof index === 'number' && onMoveItem) {
            if (movement === 'UP') {
                onMoveItem(index - 1, index);
            } else if (movement === 'DOWN') {
                onMoveItem(index + 1, index);
            }
        }
    };
    const handleDragClick = ()=>{
        if (isSelected) {
            if (onDropItem) {
                onDropItem(index);
            }
            setIsSelected(false);
        } else {
            if (onGrabItem) {
                onGrabItem(index);
            }
            setIsSelected(true);
        }
    };
    const handleCancel = ()=>{
        if (isSelected) {
            setIsSelected(false);
            if (onCancel) {
                onCancel(index);
            }
        }
    };
    const handleKeyDown = (e)=>{
        if (!active) {
            return;
        }
        if (e.key === 'Tab' && !isSelected) {
            return;
        }
        e.preventDefault();
        switch(e.key){
            case ' ':
            case 'Enter':
                handleDragClick();
                break;
            case 'Escape':
                handleCancel();
                break;
            case 'ArrowDown':
            case 'ArrowRight':
                handleMove('DOWN');
                break;
            case 'ArrowUp':
            case 'ArrowLeft':
                handleMove('UP');
                break;
        }
    };
    return handleKeyDown;
};

const DIRECTIONS = {
    UPWARD: 'upward',
    DOWNWARD: 'downward'
};
const DROP_SENSITIVITY = {
    REGULAR: 'regular',
    IMMEDIATE: 'immediate'
};
/**
 * A utility hook abstracting the general drag and drop hooks from react-dnd.
 * Centralising the same behaviours and by default offering keyboard support.
 */ const useDragAndDrop = (active, { type = 'STRAPI_DND', index, item, onStart, onEnd, onGrabItem, onDropItem, onCancel, onMoveItem, dropSensitivity = DROP_SENSITIVITY.REGULAR })=>{
    const objectRef = React.useRef(null);
    const [{ handlerId, isOver }, dropRef] = useDrop({
        accept: type,
        collect (monitor) {
            return {
                handlerId: monitor.getHandlerId(),
                isOver: monitor.isOver({
                    shallow: true
                })
            };
        },
        drop (item) {
            const draggedIndex = item.index;
            const newIndex = index;
            if (isOver && onDropItem) {
                onDropItem(draggedIndex, newIndex);
            }
        },
        hover (item, monitor) {
            if (!objectRef.current || !onMoveItem) {
                return;
            }
            const dragIndex = item.index;
            const newIndex = index;
            const hoverBoundingRect = objectRef.current?.getBoundingClientRect();
            const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
            const clientOffset = monitor.getClientOffset();
            if (!clientOffset) return;
            const hoverClientY = clientOffset && clientOffset.y - hoverBoundingRect.top;
            if (typeof dragIndex === 'number' && typeof newIndex === 'number') {
                if (dragIndex === newIndex) {
                    // Don't replace items with themselves
                    return;
                }
                if (dropSensitivity === DROP_SENSITIVITY.REGULAR) {
                    // Dragging downwards
                    if (dragIndex < newIndex && hoverClientY < hoverMiddleY) {
                        return;
                    }
                    // Dragging upwards
                    if (dragIndex > newIndex && hoverClientY > hoverMiddleY) {
                        return;
                    }
                }
                // Time to actually perform the action
                onMoveItem(newIndex, dragIndex);
                item.index = newIndex;
            } else {
                // Using numbers as indices doesn't work for nested list items with path like [1, 1, 0]
                if (Array.isArray(dragIndex) && Array.isArray(newIndex)) {
                    // Indices comparison to find item position in nested list
                    const minLength = Math.min(dragIndex.length, newIndex.length);
                    let areEqual = true;
                    let isLessThan = false;
                    let isGreaterThan = false;
                    for(let i = 0; i < minLength; i++){
                        if (dragIndex[i] < newIndex[i]) {
                            isLessThan = true;
                            areEqual = false;
                            break;
                        } else if (dragIndex[i] > newIndex[i]) {
                            isGreaterThan = true;
                            areEqual = false;
                            break;
                        }
                    }
                    // Don't replace items with themselves
                    if (areEqual && dragIndex.length === newIndex.length) {
                        return;
                    }
                    if (dropSensitivity === DROP_SENSITIVITY.REGULAR) {
                        // Dragging downwards
                        if (isLessThan && !isGreaterThan && hoverClientY < hoverMiddleY) {
                            return;
                        }
                        // Dragging upwards
                        if (isGreaterThan && !isLessThan && hoverClientY > hoverMiddleY) {
                            return;
                        }
                    }
                }
                onMoveItem(newIndex, dragIndex);
                item.index = newIndex;
            }
        }
    });
    const getDragDirection = (monitor)=>{
        if (monitor && monitor.isDragging() && !monitor.didDrop() && monitor.getInitialClientOffset() && monitor.getClientOffset()) {
            const deltaY = monitor.getInitialClientOffset().y - monitor.getClientOffset().y;
            if (deltaY > 0) return DIRECTIONS.UPWARD;
            if (deltaY < 0) return DIRECTIONS.DOWNWARD;
            return null;
        }
        return null;
    };
    const [{ isDragging, direction }, dragRef, dragPreviewRef] = useDrag({
        type,
        item () {
            if (onStart) {
                onStart();
            }
            /**
       * This will be attached and it helps define the preview sizes
       * when a component is flexy e.g. Relations
       */ const { width } = objectRef.current?.getBoundingClientRect() ?? {};
            return {
                index,
                width,
                ...item
            };
        },
        end () {
            if (onEnd) {
                onEnd();
            }
        },
        canDrag: active,
        /**
     * This is useful when the item is in a virtualized list.
     * However, if we don't have an ID then we want the libraries
     * defaults to take care of this.
     */ isDragging: item?.id ? (monitor)=>{
            return item.id === monitor.getItem().id;
        } : undefined,
        collect: (monitor)=>({
                isDragging: monitor.isDragging(),
                initialOffset: monitor.getInitialClientOffset(),
                currentOffset: monitor.getClientOffset(),
                direction: getDragDirection(monitor)
            })
    });
    const handleKeyDown = useKeyboardDragAndDrop(active, index, {
        onGrabItem,
        onDropItem,
        onCancel,
        onMoveItem
    });
    return [
        {
            handlerId,
            isDragging,
            handleKeyDown,
            isOverDropTarget: isOver,
            direction
        },
        objectRef,
        dropRef,
        dragRef,
        dragPreviewRef
    ];
};

/**
 * Deeply get a value from an object via its path.
 */ function getIn(obj, key, def, pathStartIndex = 0) {
    const path = toPath(key);
    while(obj && pathStartIndex < path.length){
        obj = obj[path[pathStartIndex++]];
    }
    // check if path is not in the end
    if (pathStartIndex !== path.length && !obj) {
        return def;
    }
    return obj === undefined ? def : obj;
}
/** @internal is the given object an Object? */ const isObject = (obj)=>obj !== null && typeof obj === 'object' && !Array.isArray(obj);
/** @internal is the given object an integer? */ const isInteger = (obj)=>String(Math.floor(Number(obj))) === obj;
/**
 * Deeply set a value from in object via its path. If the value at `path`
 * has changed, return a shallow copy of obj with `value` set at `path`.
 * If `value` has not changed, return the original `obj`.
 *
 * Existing objects / arrays along `path` are also shallow copied. Sibling
 * objects along path retain the same internal js reference. Since new
 * objects / arrays are only created along `path`, we can test if anything
 * changed in a nested structure by comparing the object's reference in
 * the old and new object, similar to how russian doll cache invalidation
 * works.
 *
 * In earlier versions of this function, which used cloneDeep, there were
 * issues whereby settings a nested value would mutate the parent
 * instead of creating a new object. `clone` avoids that bug making a
 * shallow copy of the objects along the update path
 * so no object is mutated in place.
 *
 * Before changing this function, please read through the following
 * discussions.
 *
 * @see https://github.com/developit/linkstate
 * @see https://github.com/jaredpalmer/formik/pull/123
 */ function setIn(obj, path, value) {
    const res = clone(obj); // this keeps inheritance when obj is a class
    let resVal = res;
    let i = 0;
    const pathArray = toPath(path);
    for(; i < pathArray.length - 1; i++){
        const currentPath = pathArray[i];
        const currentObj = getIn(obj, pathArray.slice(0, i + 1));
        if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {
            resVal = resVal[currentPath] = clone(currentObj);
        } else {
            const nextPath = pathArray[i + 1];
            resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
        }
    }
    // Return original object if new value is the same as current
    if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {
        return obj;
    }
    {
        delete resVal[pathArray[i]];
    }
    // If the path array has a single element, the loop did not run.
    // Deleting on `resVal` had no effect in this scenario, so we delete on the result instead.
    if (i === 0 && value === undefined) {
        delete res[pathArray[i]];
    }
    return res;
}

export { DIRECTIONS as D, ItemTypes as I, DROP_SENSITIVITY as a, getIn as g, setIn as s, useDragAndDrop as u };
//# sourceMappingURL=objects-D2z-IJgu.mjs.map
